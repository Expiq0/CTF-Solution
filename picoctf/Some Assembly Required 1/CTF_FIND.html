<!DOCTYPE html>

<html dir="rtl" lang="ar">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Some Assembly Required 1 Challenge Analyzer</title>
<style>
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
            color: #c9d1d9;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            background: rgba(88, 166, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 1px solid #58a6ff;
        }
        .header h1 {
            color: #58a6ff;
            margin: 0;
            font-size: 2.5em;
            text-shadow: 0 0 20px #58a6ff;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .section {
            background: rgba(22, 27, 34, 0.8);
            border: 1px solid #30363d;
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .section h3 {
            color: #f85149;
            border-bottom: 2px solid #f85149;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        pre {
            background: #0d1117;
            border: 1px solid #30363d;
            padding: 15px;
            overflow-x: auto;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
        }
        button {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            border-radius: 8px;
            margin: 5px;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(35, 134, 54, 0.3);
        }
        button:hover {
            background: linear-gradient(135deg, #2ea043 0%, #238636 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(35, 134, 54, 0.4);
        }
        .danger {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
            box-shadow: 0 4px 15px rgba(218, 54, 51, 0.3);
        }
        .danger:hover {
            background: linear-gradient(135deg, #f85149 0%, #da3633 100%);
            box-shadow: 0 6px 20px rgba(218, 54, 51, 0.4);
        }
        .highlight {
            background: rgba(187, 128, 9, 0.3);
            color: #f2cc60;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        .success {
            color: #3fb950;
            font-weight: bold;
            font-size: 1.1em;
        }
        .error {
            color: #f85149;
            font-weight: bold;
        }
        .flag-candidate {
            background: rgba(63, 185, 80, 0.2);
            border: 1px solid #3fb950;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        input[type="text"] {
            flex: 1;
            padding: 12px;
            background: rgba(33, 38, 45, 0.8);
            color: #c9d1d9;
            border: 1px solid #30363d;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
        }
        .status {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.loading {
            background: rgba(88, 166, 255, 0.2);
            border: 1px solid #58a6ff;
            color: #58a6ff;
        }
        .status.success {
            background: rgba(63, 185, 80, 0.2);
            border: 1px solid #3fb950;
            color: #3fb950;
        }
        .status.error {
            background: rgba(248, 81, 73, 0.2);
            border: 1px solid #f85149;
            color: #f85149;
        }
    </style>
</head>
<body>
<div class="container">
<div class="header">
<h1>ğŸ¯ Some Assembly Required 1 Challenge Analyzer</h1>
<p>Analyze WebAssembly and Find the Flag</p>
</div>
<div class="section full-width">
<h3>ğŸ“ Upload file WASM</h3>
<div class="input-group">
<input accept=".wasm" id="wasmFile" style="flex: none; width: 300px;" type="file"/>
<button onclick="loadWasm()">Analyze File</button>
<button class="danger" onclick="createMockWasm()">Create Mock File</button>
</div>
<div id="loadStatus"></div>
</div>
<div class="grid">
<div class="section">
<h3>ğŸ“Š File information</h3>
<pre id="fileInfo">Please upload a WASM file first...</pre>
</div>
<div class="section">
<h3>ğŸ”Extracted texts</h3>
<pre id="stringsOutput">Waiting for analysis...</pre>
</div>
</div>
<div class="section full-width">
<h3>ğŸ§ª Function Test</h3>
<div class="input-group">
<input id="testInput" placeholder="Enter the text to test (e.g., flag{test})" type="text"/>
<button onclick="testFlag()">Test Flag</button>
<button onclick="bruteForceFlag()">Smart Search</button>
</div>
<pre id="testResults">Test results will appear here...</pre>
</div>
<div class="grid">
<div class="section">
<h3>âš™ï¸ Exported functions</h3>
<pre id="exportsInfo">Waiting for file load...</pre>
</div>
<div class="section">
<h3>ğŸ’¾ Memory analysis</h3>
<button onclick="analyzeMemory()">Analyze Memory</button>
<pre id="memoryInfo">Click to analyze memory...</pre>
</div>
</div>
<div class="section full-width">
<h3>ğŸ¯ Attempts to find Flag</h3>
<div id="flagAttempts"></div>
<button onclick="tryCommonFlags()">Try Common Flags</button>
<button onclick="analyzeAlgorithm()">Algorithm Analysis</button>
</div>
</div>
<script>
        let wasmInstance = null;
        let wasmBytes = null;
        let flagAttempts = 0;

        function createMockWasm() {
            // WebAssembly Ø¨Ø³ÙŠØ· ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ check_flag Ùˆ copy_char
            const wasmCode = new Uint8Array([
                0x00, 0x61, 0x73, 0x6d, // Magic number
                0x01, 0x00, 0x00, 0x00, // Version
                // Type section
                0x01, 0x08, 0x02,       // section id, size, count
                0x60, 0x02, 0x7f, 0x7f, 0x00, // func type (i32, i32) -> ()
                0x60, 0x00, 0x01, 0x7f, // func type () -> i32
                // Function section
                0x03, 0x03, 0x02, 0x00, 0x01, // section id, size, count, func 0, func 1
                // Memory section
                0x05, 0x03, 0x01, 0x00, 0x01, // section id, size, count, min pages
                // Export section
                0x07, 0x17, 0x03,       // section id, size, count
                0x09, 0x63, 0x6f, 0x70, 0x79, 0x5f, 0x63, 0x68, 0x61, 0x72, 0x00, 0x00, // "copy_char" func 0
                0x0a, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x00, 0x01, // "check_flag" func 1
                0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, // "memory"
                // Code section
                0x0a, 0x09, 0x02,       // section id, size, count
                0x02, 0x00, 0x0b,       // func 0: copy_char (empty)
                0x04, 0x00, 0x41, 0x01, 0x0b // func 1: check_flag (return 1)
            ]);
            
            const blob = new Blob([wasmCode], { type: 'application/wasm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'test.wasm';
            a.click();
            URL.revokeObjectURL(url);
            
            document.getElementById('loadStatus').innerHTML = '<div class="status success">ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ØªØ¬Ø±ÙŠØ¨ÙŠ ÙˆØªØ­Ù…ÙŠÙ„Ù‡</div>';
        }

        async function loadWasm() {
            const fileInput = document.getElementById('wasmFile');
            const file = fileInput.files[0];
            
            if (!file) {
                document.getElementById('loadStatus').innerHTML = '<div class="status error">Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù WASM</div>';
                return;
            }

            document.getElementById('loadStatus').innerHTML = '<div class="status loading">Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù„Ù...</div>';

            try {
                wasmBytes = new Uint8Array(await file.arrayBuffer());
                
                analyzeFileInfo(file);
                
                const wasmModule = await WebAssembly.instantiate(wasmBytes);
                wasmInstance = wasmModule.instance;
                
                analyzeExports();
                extractStrings();
                
                document.getElementById('loadStatus').innerHTML = '<div class="status success">âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ ÙˆØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­</div>';
                
            } catch (err) {
                document.getElementById('loadStatus').innerHTML = `<div class="status error">âŒ Ø®Ø·Ø£: ${err.message}</div>`;
            }
        }

        function analyzeFileInfo(file) {
            let info = `ğŸ“„ file name: ${file.name}\n`;
            info += `ğŸ“ File size: ${wasmBytes.length} Ø¨Ø§ÙŠØª\n`;
            info += `ğŸ“… Last modified: ${file.lastModified ? new Date(file.lastModified).toLocaleString('ar') : 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}\n\n`;
            
            // ÙØ­Øµ WASM header
            if (wasmBytes.length >= 8) {
                const magic = wasmBytes.slice(0, 4);
                const version = wasmBytes.slice(4, 8);
                
                if (magic[0] === 0x00 && magic[1] === 0x61 && magic[2] === 0x73 && magic[3] === 0x6D) {
                    info += 'âœ… file WebAssembly correct\n';
                    const versionNum = version[0] | (version[1] << 8) | (version[2] << 16) | (version[3] << 24);
                    info += `ğŸ“¦ Release WASM: ${versionNum}\n`;
                } else {
                    info += 'âŒNot a WebAssembly fileØµØ­ÙŠØ­\n';
                }
            }
            
            info += '\nğŸ”structural analysis:\n';
            let offset = 8; // Ø¨Ø¹Ø¯ header
            while (offset < wasmBytes.length) {
                if (offset + 1 >= wasmBytes.length) break;
                
                const sectionType = wasmBytes[offset];
                const sectionNames = [
                    'Custom', 'Type', 'Import', 'Function', 'Table', 
                    'Memory', 'Global', 'Export', 'Start', 'Element', 
                    'Code', 'Data'
                ];
                
                if (sectionType < sectionNames.length) {
                    info += `  - ${sectionNames[sectionType]} Section\n`;
                }
                
                offset += 2;
                if (offset < wasmBytes.length) {
                    const size = wasmBytes[offset];
                    offset += size + 1;
                } else {
                    break;
                }
            }
            
            document.getElementById('fileInfo').textContent = info;
        }

        function analyzeExports() {
            if (!wasmInstance) return;
            
            let output = 'ğŸ”§ Exported functions and variables:\n\n';
            
            for (const [name, value] of Object.entries(wasmInstance.exports)) {
                const type = typeof value;
                output += `ğŸ“Œ ${name}: ${type}`;
                
                if (type === 'function') {
                    output += ` (${value.length} Transactions)\n`;
                    
                    if (name === 'check_flag') {
                        try {
                            const result = value();
                            output += `   â””â”€ Instant test : ${result}\n`;
                        } catch (err) {
                            output += `   â””â”€ Test error : ${err.message}\n`;
                        }
                    }
                } else if (type === 'object') {
                    if (value.constructor.name === 'WebAssembly.Memory') {
                        output += ` (${value.buffer.byteLength} byte)\n`;
                    } else {
                        output += `\n`;
                    }
                } else {
                    output += `\n`;
                }
            }
            
            document.getElementById('exportsInfo').textContent = output;
        }

        function extractStrings() {
            if (!wasmBytes) return;
            
            let output = 'ğŸ“ Extracted texts:\n\n';
            let strings = [];
            let currentString = '';
            let potentialFlags = [];
            
            for (let i = 0; i < wasmBytes.length; i++) {
                const byte = wasmBytes[i];
                
                if (byte >= 32 && byte <= 126) {
                    currentString += String.fromCharCode(byte);
                } else {
                    if (currentString.length >= 3) {
                        strings.push({text: currentString, offset: i - currentString.length});
                        
                        const lower = currentString.toLowerCase();
                        if (lower.includes('flag') || lower.includes('ctf') || 
                            currentString.includes('{') || currentString.includes('}') ||
                            /^[a-zA-Z0-9_{}]+$/.test(currentString)) {
                            potentialFlags.push(currentString);
                        }
                    }
                    currentString = '';
                }
            }
            
            output += 'ğŸ¯ Flags Possible:\n';
            if (potentialFlags.length > 0) {
                potentialFlags.forEach((flag, index) => {
                    output += `  [${index + 1}] ${flag}\n`;
                });
            } else {
                output += '  No flags foundÙˆØ§Ø¶Ø­Ø©\n';
            }
            
            output += '\nğŸ“œ All texts:\n';
            strings.slice(0, 20).forEach((str, index) => {
                output += `[${str.offset.toString(16)}]: "${str.text}"\n`;
            });
            
            if (strings.length > 20) {
                output += `... Ùˆ ${strings.length - 20} Additional text\n`;
            }
            
            document.getElementById('stringsOutput').textContent = output;
            
            if (potentialFlags.length > 0) {
                setTimeout(() => testPotentialFlags(potentialFlags), 1000);
            }
        }

        function testFlag() {
            const input = document.getElementById('testInput').value.trim();
            if (!input) {
                document.getElementById('testResults').textContent = 'Please enter text for the test.';
                return;
            }
            
            testSingleFlag(input);
        }

        function testSingleFlag(flagText) {
            if (!wasmInstance) {
                document.getElementById('testResults').textContent = 'âŒ WASM file must be uploadedØ£ÙˆÙ„Ø§Ù‹';
                return;
            }
            
            flagAttempts++;
            let output = `ğŸ§ªTest number ${flagAttempts}: "${flagText}"\n`;
            output += `ğŸ“ Text length: ${flagText.length}\n\n`;
            
            try {
                // Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù…Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£ØµÙ„ÙŠ
                if (wasmInstance.exports.copy_char) {
                    output += 'ğŸ“ Ù†Ø³Ø® Ø§Ù„Ø£Ø­Ø±Ù:\n';
                    
                    for (let i = 0; i < flagText.length; i++) {
                        const charCode = flagText.charCodeAt(i);
                        wasmInstance.exports.copy_char(charCode, i);
                        output += `  [${i}] '${flagText[i]}' (${charCode})\n`;
                    }
                    
                    // null terminator
                    wasmInstance.exports.copy_char(0, flagText.length);
                    output += `  [${flagText.length}] NULL (0)\n\n`;
                }
                
                // Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØ­Ù‚Ù‚
                if (wasmInstance.exports.check_flag) {
                    const result = wasmInstance.exports.check_flag();
                    output += 'ğŸ” Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù‚Ù‚:\n';
                    
                    if (result === 1) {
                        output += `ğŸ‰ SUCCESS! Ø§Ù„Ù†ØªÙŠØ¬Ø©: ${result}\n`;
                        output += `ğŸ† ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Flag: "${flagText}"\n`;
                        
                        // Ø¥Ø¶Ø§ÙØ© ØªÙ†Ø¨ÙŠÙ‡ Ø¨ØµØ±ÙŠ
                        document.getElementById('testResults').innerHTML = 
                            `<div class="flag-candidate">${output}</div>`;
                        return;
                    } else {
                        output += `âŒ FAILED. Ø§Ù„Ù†ØªÙŠØ¬Ø©: ${result}\n`;
                    }
                } else {
                    output += 'âŒ Ø¯Ø§Ù„Ø© check_flag ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©\n';
                }
                
            } catch (err) {
                output += `ğŸ’¥ Ø®Ø·Ø£: ${err.message}\n`;
            }
            
            document.getElementById('testResults').textContent = output;
        }

        function testPotentialFlags(flags) {
            flags.forEach((flag, index) => {
                setTimeout(() => {
                    testSingleFlag(flag);
                }, index * 500); // ØªØ£Ø®ÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª
            });
        }

        function bruteForceFlag() {
            if (!wasmInstance) {
                alert('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù WASM Ø£ÙˆÙ„Ø§Ù‹');
                return;
            }
            
            const commonFlags = [
                'flag{hello}', 'flag{test}', 'flag{wasm}', 'flag{ctf}',
                'CTF{test}', 'CTF{wasm}', 'CTF{hello}', 'CTF{flag}',
                'flag{webassembly}', 'flag{challenge}', 'flag{easy}',
                'flag{simple}', 'flag{basic}', 'test', 'admin', 'password',
                'flag{password}', 'flag{admin}', 'flag{secret}',
                'flag{hidden}', 'flag{found}', 'flag{success}'
            ];
            
            let output = 'ğŸ”„ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Flag...\n\n';
            document.getElementById('testResults').textContent = output;
            
            commonFlags.forEach((flag, index) => {
                setTimeout(() => {
                    testSingleFlag(flag);
                }, index * 200);
            });
        }

        function tryCommonFlags() {
            const attempts = document.getElementById('flagAttempts');
            attempts.innerHTML = '<h4>ğŸ¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Flag:</h4>';
            
            const commonPatterns = [
                'flag{webassembly_is_cool}',
                'flag{wasm_challenge}',
                'flag{reverse_engineering}',
                'flag{javascript_obfuscation}',
                'CTF{wasm_analysis}',
                'CTF{binary_analysis}',
                'flag{memory_analysis}',
                'flag{exports_analysis}'
            ];
            
            commonPatterns.forEach((pattern, index) => {
                setTimeout(() => {
                    const result = testSingleFlag(pattern);
                    const div = document.createElement('div');
                    div.textContent = `Ù…Ø­Ø§ÙˆÙ„Ø© ${index + 1}: ${pattern}`;
                    attempts.appendChild(div);
                }, index * 300);
            });
        }

        function analyzeMemory() {
            if (!wasmInstance) {
                document.getElementById('memoryInfo').textContent = 'âŒ ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù WASM Ø£ÙˆÙ„Ø§Ù‹';
                return;
            }
            
            let output = 'ğŸ’¾ ØªØ­Ù„ÙŠÙ„ Ø°Ø§ÙƒØ±Ø© WebAssembly:\n\n';
            
            try {
                if (wasmInstance.exports.memory) {
                    const memory = wasmInstance.exports.memory;
                    const buffer = new Uint8Array(memory.buffer);
                    
                    output += `ğŸ“Š Ø­Ø¬Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø©: ${buffer.length} Ø¨Ø§ÙŠØª\n`;
                    output += `ğŸ“„ Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª: ${buffer.length / 65536}\n\n`;
                    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ù†Ù…Ø§Ø· Ù…Ø«ÙŠØ±Ø© Ù„Ù„Ø§Ù‡ØªÙ…Ø§Ù…
                    output += 'ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ù†Ù…Ø§Ø·:\n';
                    
                    let foundPatterns = false;
                    for (let i = 0; i < Math.min(1024, buffer.length - 10); i++) {
                        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† "flag" Ø£Ùˆ "CTF"
                        if (buffer[i] === 0x66 && buffer[i+1] === 0x6C && 
                            buffer[i+2] === 0x61 && buffer[i+3] === 0x67) {
                            output += `  ğŸ“ "flag" ÙÙŠ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ${i.toString(16)}\n`;
                            foundPatterns = true;
                        }
                        
                        if (buffer[i] === 0x43 && buffer[i+1] === 0x54 && buffer[i+2] === 0x46) {
                            output += `  ğŸ“ "CTF" ÙÙŠ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ${i.toString(16)}\n`;
                            foundPatterns = true;
                        }
                    }
                    
                    if (!foundPatterns) {
                        output += '  Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ù†Ù…Ø§Ø· ÙˆØ§Ø¶Ø­Ø©\n';
                    }
                    
                    output += '\nğŸ“‹ Ø¹ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© (Ø£ÙˆÙ„ 128 Ø¨Ø§ÙŠØª):\n';
                    for (let i = 0; i < Math.min(128, buffer.length); i += 16) {
                        let line = i.toString(16).padStart(4, '0') + ': ';
                        let ascii = '';
                        
                        for (let j = 0; j < 16 && i + j < buffer.length; j++) {
                            const byte = buffer[i + j];
                            line += byte.toString(16).padStart(2, '0') + ' ';
                            ascii += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                        }
                        
                        output += line.padEnd(52) + ' |' + ascii + '|\n';
                    }
                    
                } else {
                    output += 'âŒ Ø§Ù„Ø°Ø§ÙƒØ±Ø© ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø£Ùˆ ØºÙŠØ± Ù…ÙØµØ¯Ø±Ø©\n';
                }
                
            } catch (err) {
                output += `ğŸ’¥ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°Ø§ÙƒØ±Ø©: ${err.message}\n`;
            }
            
            document.getElementById('memoryInfo').textContent = output;
        }

        function analyzeAlgorithm() {
            let analysis = `
ğŸ§  ØªØ­Ù„ÙŠÙ„ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„ØªØ­Ù‚Ù‚:

ğŸ“‹ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ JavaScript Ø§Ù„Ù…ÙÙƒÙˆÙƒ:
1. ÙŠØªÙ… Ù†Ø³Ø® ÙƒÙ„ Ø­Ø±Ù Ù…Ù† Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… copy_char(charCode, index)
2. ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© null terminator ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© copy_char(0, length)
3. ÙŠØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ check_flag() Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
4. Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© 1ØŒ ÙŠØ¹Ø±Ø¶ "Correct!"ØŒ ÙˆØ¥Ù„Ø§ "Incorrect!"

ğŸ” Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„:
- Ù…Ù‚Ø§Ø±Ù†Ø© Ù…Ø¨Ø§Ø´Ø±Ø©: Flag Ù…Ø®Ø²Ù† ÙƒÙ€ string ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
- Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ØªØ´ÙÙŠØ± Ø¨Ø³ÙŠØ·Ø©: XORØŒ Caesar cipher
- checksum: Ù…Ø¬Ù…ÙˆØ¹ Ù‚ÙŠÙ… ASCII
- Ø·ÙˆÙ„ Ù…Ø­Ø¯Ø¯: ÙØ­Øµ Ø·ÙˆÙ„ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø¯Ø®Ù„

ğŸ’¡ Ù†ØµØ§Ø¦Ø­:
- Ø¬Ø±Ø¨ Ø§Ø³ØªØ®Ø±Ø§Ø¬ strings Ù…Ù† Ø§Ù„Ù…Ù„Ù
- Ø­Ù„Ù„ memory layout
- Ø§Ø³ØªØ®Ø¯Ù… debugger Ù„ÙÙ‡Ù… check_flag()
- Ø§Ø¨Ø­Ø« Ø¹Ù† hardcoded values ÙÙŠ Ø§Ù„ÙƒÙˆØ¯
            `;
            
            document.getElementById('flagAttempts').innerHTML = `<pre style="background: rgba(88, 166, 255, 0.1); border-left: 4px solid #58a6ff; padding: 15px;">${analysis}</pre>`;
        }

        window.onload = function() {
            document.getElementById('loadStatus').innerHTML = '<div class="status">Select a WASM file to start analysis.</div>';
        };
    </script>
</body>
</html>